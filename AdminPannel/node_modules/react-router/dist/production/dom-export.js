<<<<<<< HEAD
"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }/**
 * react-router v7.8.1
=======
/**
 * react-router v7.6.3
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
<<<<<<< HEAD
"use client";


var _chunkKHPQXKYMjs = require('./chunk-KHPQXKYM.js');

// lib/dom-export/dom-router-provider.tsx
var _react = require('react'); var React = _interopRequireWildcard(_react); var React2 = _interopRequireWildcard(_react);
var _reactdom = require('react-dom'); var ReactDOM = _interopRequireWildcard(_reactdom);
var _reactrouter = require('react-router');
function RouterProvider(props) {
  return /* @__PURE__ */ React.createElement(_reactrouter.RouterProvider, { flushSync: ReactDOM.flushSync, ...props });
}

// lib/dom-export/hydrated-router.tsx


















=======
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dom-export.ts
var dom_export_exports = {};
__export(dom_export_exports, {
  HydratedRouter: () => HydratedRouter,
  RouterProvider: () => RouterProvider
});
module.exports = __toCommonJS(dom_export_exports);

// lib/dom-export/dom-router-provider.tsx
var React = __toESM(require("react"));
var ReactDOM = __toESM(require("react-dom"));
var import_react_router = require("react-router");
function RouterProvider(props) {
  return /* @__PURE__ */ React.createElement(import_react_router.RouterProvider, { flushSync: ReactDOM.flushSync, ...props });
}

// lib/dom-export/hydrated-router.tsx
var React2 = __toESM(require("react"));
var import_react_router2 = require("react-router");
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
var ssrInfo = null;
var router = null;
function initSsrInfo() {
  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {
    if (window.__reactRouterManifest.sri === true) {
      const importMap = document.querySelector("script[rr-importmap]");
<<<<<<< HEAD
      if (_optionalChain([importMap, 'optionalAccess', _ => _.textContent])) {
=======
      if (importMap?.textContent) {
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
        try {
          window.__reactRouterManifest.sri = JSON.parse(
            importMap.textContent
          ).integrity;
        } catch (err) {
          console.error("Failed to parse import map", err);
        }
      }
    }
    ssrInfo = {
      context: window.__reactRouterContext,
      manifest: window.__reactRouterManifest,
      routeModules: window.__reactRouterRouteModules,
      stateDecodingPromise: void 0,
      router: void 0,
      routerInitialized: false
    };
  }
}
function createHydratedRouter({
  unstable_getContext
}) {
  initSsrInfo();
  if (!ssrInfo) {
    throw new Error(
      "You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`"
    );
  }
  let localSsrInfo = ssrInfo;
  if (!ssrInfo.stateDecodingPromise) {
    let stream = ssrInfo.context.stream;
<<<<<<< HEAD
    _reactrouter.UNSAFE_invariant.call(void 0, stream, "No stream found for single fetch decoding");
    ssrInfo.context.stream = void 0;
    ssrInfo.stateDecodingPromise = _reactrouter.UNSAFE_decodeViaTurboStream.call(void 0, stream, window).then((value) => {
=======
    (0, import_react_router2.UNSAFE_invariant)(stream, "No stream found for single fetch decoding");
    ssrInfo.context.stream = void 0;
    ssrInfo.stateDecodingPromise = (0, import_react_router2.UNSAFE_decodeViaTurboStream)(stream, window).then((value) => {
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
      ssrInfo.context.state = value.value;
      localSsrInfo.stateDecodingPromise.value = true;
    }).catch((e) => {
      localSsrInfo.stateDecodingPromise.error = e;
    });
  }
  if (ssrInfo.stateDecodingPromise.error) {
    throw ssrInfo.stateDecodingPromise.error;
  }
  if (!ssrInfo.stateDecodingPromise.value) {
    throw ssrInfo.stateDecodingPromise;
  }
<<<<<<< HEAD
  let routes = _reactrouter.UNSAFE_createClientRoutes.call(void 0, 
=======
  let routes = (0, import_react_router2.UNSAFE_createClientRoutes)(
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
    ssrInfo.manifest.routes,
    ssrInfo.routeModules,
    ssrInfo.context.state,
    ssrInfo.context.ssr,
    ssrInfo.context.isSpaMode
  );
  let hydrationData = void 0;
  if (ssrInfo.context.isSpaMode) {
    let { loaderData } = ssrInfo.context.state;
<<<<<<< HEAD
    if (_optionalChain([ssrInfo, 'access', _2 => _2.manifest, 'access', _3 => _3.routes, 'access', _4 => _4.root, 'optionalAccess', _5 => _5.hasLoader]) && loaderData && "root" in loaderData) {
=======
    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && "root" in loaderData) {
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
      hydrationData = {
        loaderData: {
          root: loaderData.root
        }
      };
    }
  } else {
<<<<<<< HEAD
    hydrationData = _reactrouter.UNSAFE_getHydrationData.call(void 0, 
      ssrInfo.context.state,
      routes,
      (routeId) => ({
        clientLoader: _optionalChain([ssrInfo, 'access', _6 => _6.routeModules, 'access', _7 => _7[routeId], 'optionalAccess', _8 => _8.clientLoader]),
        hasLoader: _optionalChain([ssrInfo, 'access', _9 => _9.manifest, 'access', _10 => _10.routes, 'access', _11 => _11[routeId], 'optionalAccess', _12 => _12.hasLoader]) === true,
        hasHydrateFallback: _optionalChain([ssrInfo, 'access', _13 => _13.routeModules, 'access', _14 => _14[routeId], 'optionalAccess', _15 => _15.HydrateFallback]) != null
      }),
      window.location,
      _optionalChain([window, 'access', _16 => _16.__reactRouterContext, 'optionalAccess', _17 => _17.basename]),
      ssrInfo.context.isSpaMode
    );
    if (hydrationData && hydrationData.errors) {
      hydrationData.errors = _reactrouter.UNSAFE_deserializeErrors.call(void 0, hydrationData.errors);
    }
  }
  let router2 = _reactrouter.UNSAFE_createRouter.call(void 0, {
    routes,
    history: _reactrouter.UNSAFE_createBrowserHistory.call(void 0, ),
    basename: ssrInfo.context.basename,
    unstable_getContext,
    hydrationData,
    hydrationRouteProperties: _reactrouter.UNSAFE_hydrationRouteProperties,
    mapRouteProperties: _reactrouter.UNSAFE_mapRouteProperties,
    future: {
      unstable_middleware: ssrInfo.context.future.unstable_middleware
    },
    dataStrategy: _reactrouter.UNSAFE_getTurboStreamSingleFetchDataStrategy.call(void 0, 
=======
    hydrationData = (0, import_react_router2.UNSAFE_getHydrationData)(
      ssrInfo.context.state,
      routes,
      (routeId) => ({
        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,
        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,
        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null
      }),
      window.location,
      window.__reactRouterContext?.basename,
      ssrInfo.context.isSpaMode
    );
    if (hydrationData && hydrationData.errors) {
      hydrationData.errors = (0, import_react_router2.UNSAFE_deserializeErrors)(hydrationData.errors);
    }
  }
  let router2 = (0, import_react_router2.UNSAFE_createRouter)({
    routes,
    history: (0, import_react_router2.UNSAFE_createBrowserHistory)(),
    basename: ssrInfo.context.basename,
    unstable_getContext,
    hydrationData,
    hydrationRouteProperties: import_react_router2.UNSAFE_hydrationRouteProperties,
    mapRouteProperties: import_react_router2.UNSAFE_mapRouteProperties,
    future: {
      unstable_middleware: ssrInfo.context.future.unstable_middleware
    },
    dataStrategy: (0, import_react_router2.UNSAFE_getTurboStreamSingleFetchDataStrategy)(
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
      () => router2,
      ssrInfo.manifest,
      ssrInfo.routeModules,
      ssrInfo.context.ssr,
      ssrInfo.context.basename
    ),
<<<<<<< HEAD
    patchRoutesOnNavigation: _reactrouter.UNSAFE_getPatchRoutesOnNavigationFunction.call(void 0, 
=======
    patchRoutesOnNavigation: (0, import_react_router2.UNSAFE_getPatchRoutesOnNavigationFunction)(
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
      ssrInfo.manifest,
      ssrInfo.routeModules,
      ssrInfo.context.ssr,
      ssrInfo.context.routeDiscovery,
      ssrInfo.context.isSpaMode,
      ssrInfo.context.basename
    )
  });
  ssrInfo.router = router2;
  if (router2.state.initialized) {
    ssrInfo.routerInitialized = true;
    router2.initialize();
  }
  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */
<<<<<<< HEAD
  _reactrouter.UNSAFE_createClientRoutesWithHMRRevalidationOptOut;
=======
  import_react_router2.UNSAFE_createClientRoutesWithHMRRevalidationOptOut;
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
  window.__reactRouterDataRouter = router2;
  return router2;
}
function HydratedRouter(props) {
  if (!router) {
    router = createHydratedRouter({
      unstable_getContext: props.unstable_getContext
    });
  }
  let [criticalCss, setCriticalCss] = React2.useState(
<<<<<<< HEAD
    process.env.NODE_ENV === "development" ? _optionalChain([ssrInfo, 'optionalAccess', _18 => _18.context, 'access', _19 => _19.criticalCss]) : void 0
  );
  React2.useEffect(() => {
    if (process.env.NODE_ENV === "development") {
      setCriticalCss(void 0);
    }
  }, []);
  React2.useEffect(() => {
    if (process.env.NODE_ENV === "development" && criticalCss === void 0) {
      document.querySelectorAll(`[${_chunkKHPQXKYMjs.CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element) => element.remove());
    }
  }, [criticalCss]);
=======
    process.env.NODE_ENV === "development" ? ssrInfo?.context.criticalCss : void 0
  );
  if (process.env.NODE_ENV === "development") {
    if (ssrInfo) {
      window.__reactRouterClearCriticalCss = () => setCriticalCss(void 0);
    }
  }
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
  let [location, setLocation] = React2.useState(router.state.location);
  React2.useLayoutEffect(() => {
    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {
      ssrInfo.routerInitialized = true;
      ssrInfo.router.initialize();
    }
  }, []);
  React2.useLayoutEffect(() => {
    if (ssrInfo && ssrInfo.router) {
      return ssrInfo.router.subscribe((newState) => {
        if (newState.location !== location) {
          setLocation(newState.location);
        }
      });
    }
  }, [location]);
<<<<<<< HEAD
  _reactrouter.UNSAFE_invariant.call(void 0, ssrInfo, "ssrInfo unavailable for HydratedRouter");
  _reactrouter.UNSAFE_useFogOFWarDiscovery.call(void 0, 
=======
  (0, import_react_router2.UNSAFE_invariant)(ssrInfo, "ssrInfo unavailable for HydratedRouter");
  (0, import_react_router2.UNSAFE_useFogOFWarDiscovery)(
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
    router,
    ssrInfo.manifest,
    ssrInfo.routeModules,
    ssrInfo.context.ssr,
    ssrInfo.context.routeDiscovery,
    ssrInfo.context.isSpaMode
  );
  return (
    // This fragment is important to ensure we match the <ServerRouter> JSX
    // structure so that useId values hydrate correctly
    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(
<<<<<<< HEAD
      _reactrouter.UNSAFE_FrameworkContext.Provider,
=======
      import_react_router2.UNSAFE_FrameworkContext.Provider,
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
      {
        value: {
          manifest: ssrInfo.manifest,
          routeModules: ssrInfo.routeModules,
          future: ssrInfo.context.future,
          criticalCss,
          ssr: ssrInfo.context.ssr,
          isSpaMode: ssrInfo.context.isSpaMode,
          routeDiscovery: ssrInfo.context.routeDiscovery
        }
      },
<<<<<<< HEAD
      /* @__PURE__ */ React2.createElement(_reactrouter.UNSAFE_RemixErrorBoundary, { location }, /* @__PURE__ */ React2.createElement(RouterProvider, { router }))
    ), /* @__PURE__ */ React2.createElement(React2.Fragment, null))
  );
}



exports.HydratedRouter = HydratedRouter; exports.RouterProvider = RouterProvider;
=======
      /* @__PURE__ */ React2.createElement(import_react_router2.UNSAFE_RemixErrorBoundary, { location }, /* @__PURE__ */ React2.createElement(RouterProvider, { router }))
    ), /* @__PURE__ */ React2.createElement(React2.Fragment, null))
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HydratedRouter,
  RouterProvider
});
>>>>>>> a928867f5fcbca21df0c09f23ef715090f8c23ab
